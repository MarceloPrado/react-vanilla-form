---
name: Documentation
route: /
---

import { Playground, PropsTable } from 'docz'

import Themed from './PlaygroundTheme'
import FormState from './FormState'
import Input from './CustomInput'
import { required, isNumber } from './validations'
import Form from '.'

# React Vanilla Form
> An unobtrusive form serializer and validator that works by following standards.

Vanilla Form is a form serialization and validation component built upon
standards. To obtain the serialized form data the only thing you need to
do is to declare your form controls (native or custom!) following the
standard input interfaces: Using `name`, `value`, `htmlFor` and `role`
properties.

Wire `onSubmit` prop to `Form` component to get the serialized data from
the form. Pass `validations` to display and catch errors in the form.
Use `onChange` (or not) to get realtime data updates.

## Usage

Difficult to explain with words, eh? Let's see it in practice. Install
`react-vanilla-form` package. The only component you need to import is
`Form`, which is the default package export:


```jsx
import Form from 'react-vanilla-form'
```

## Props documentation
<details>
  <summary>Expand/collapse props table</summary>
  <PropsTable of={Form} />
</details>

## Serialization

Wire `onSubmit` prop from `Form` and do whatever you want with the result:

<Playground>
  {() => {
    class PostalCodeFinder extends React.Component {
      render () {
        const { data, error, loading, places } = this.state

        return (
          <Form data={data} onSubmit={this.handleSubmit}>
            <label htmlFor="country">Country:</label>
            <select name="country" disabled={loading}>
              <option value="us">United States</option>
            </select>

            <label htmlFor="postalcode">Postal Code:</label>
            <input type="text" name="postalcode" disabled={loading}/>

            <br/>
            <button>Find place!</button>

            {places &&
              places.map(place =>
                <h3>{place["place name"]}, {place.state}</h3>
              )
            }

            {error &&
              <h3 style={{color: 'red'}}>{error.message}</h3>
            }
          </Form>
        )
      }

      handleSubmit (data) {
        const { country, postalcode } = data

        this.setState({ data, error: null, loading: true })

        fetch('https://api.zippopotam.us/' + country + '/' + postalcode)
          .then((res) => {
            if (res.status == 404) {
              throw new Error("No place found!")
            }
            return res.json()
          })
          .then(({places}) => this.setState({
            places,
            loading: false,
            error: null
          }))
          .catch((error) => {
            this.setState({
              places: null,
              loading: false,
              error,
            })
          })
      }

      constructor (props) {
        super(props)

        this.state = {
          data: {
            country: 'us',
          },
          loading: false,
          places: null,
        }

        this.handleSubmit = this.handleSubmit.bind(this)
      }
    }

    return <Themed><PostalCodeFinder /></Themed>
  }}
</Playground>

You can even nest objects infinite levels using the standard `fieldset` tag:

<Playground>
  <Themed>
    <FormState>
      <label htmlFor="name">
        Name:
      </label>
      <input type="text" name="name" />
      <fieldset name="address">
        <legend>Address</legend>
        <label htmlFor="street">Street:</label>
        <input type="text" name="street" title="Street" />
        <label htmlFor="number">Number:</label>
        <input type="number" name="number" title="House Number" />
        <label htmlFor="postal_code">Postal Code:</label>
        <input type="text" name="postal_code" title="Postal Code" />
      </fieldset>
      <button>Submit!</button>
    </FormState>
  </Themed>
</Playground>

## Use own components

It's also possible to use custom input components as long as they follow the
standard input interface:


<Playground>
  {() => {
    const Input = ({ name, type, onChange, title, value }) => (
      <div>
        <label htmlFor={name}>{title}</label>
        <input {...{ name, type, value, onChange: e => onChange(e.target.value) }} />
      </div>
    )

    return (
      <FormState>
        <Input type="text" name="name" title="Full name" />
        <fieldset name="address">
          <legend>Address</legend>
          <Input type="text" name="street" title="Street" />
          <Input type="number" name="number" title="House Number" />
          <Input type="text" name="postal_code" title="Postal Code" />
        </fieldset>
        <button>Submit!</button>
      </FormState>
    )
  }}
</Playground>

## Validating data

Validation is triggered both on the fly (as the user types) and when the
form is submitted. It's achieved through `validation` prop in `Form`, which
accepts an object whose keys mirror form field structure, specifying the
validation function or function array.

The validation function receives the input value and in case of an error it
should return an string with the message to be displayed for the user,
otherwise return `false` (or a falsy value).

```jsx
function required (value) {
  return value ? false : 'This field is required!'
}

function isNumber (value) {
  return parseInt(value) ? false : 'Should be a number'
}
```

To capture error messages for an `input`, use a sibling `label` component
pointing to the `label` using `htmlFor` and define the `role` as `alert`.
When using a custom input, error messages will be passed through via
`error` prop. For customizing error properties, see more on next
sections.

<Playground>
  <FormState validation={{
    name: required,
    address: {
      street: required,
      number: [required, isNumber],
    }
  }}>
    <Input name="name" title="Full name" />
    <label htmlFor="name" role="alert" />
    <fieldset name="address">
      <legend>Address</legend>
      <Input name="street" title="Street" />
      <label htmlFor="street" role="alert" />
      <Input type="text" name="number" title="House Number" />
      <label htmlFor="number" role="alert" />
      <Input name="postal_code" title="Postal Code" />
      <label htmlFor="postal_code" role="alert" />
    </fieldset>
    <button>Submit!</button>
  </FormState>
</Playground>

### Custom error properties

It is possible to receive the error message into the validated field via
props by configuring the error prop name with `customErrorProp` prop.

Let's say we want to improve the custom input component to include an
`errorMessage` prop:

```jsx
const Input = ({ name, type, onChange, title, value, errorMessage }) => (
  <div>
    <label htmlFor={name}>{title}</label>
    <input {...{ name, type, onChange, value }} />
    <label>{errorMessage}</label>
  </div>
)
```

Configure `customErrorProp="errorMessage"` on the form with the prop name:

<Playground>
  <FormState
    validation={{ name: required }}
    customErrorProp="errorMessage"
  >
    <Input name="name" title="Full name" />
    <button>Submit!</button>
  </FormState>
</Playground>

Now the custom input will receive the validation error as a prop.

### Run validations on different events

By default, validations will run on `change` event, meaning that the
feedback will be realtime, which sometimes is the desired behaviour,
but sometimes might confuse users. For this cases, it's possible to
change the event which will triggered via `validateOn` prop. The
supported events are `change`, `focus`, `blur` and `submit`. Using
`submit` will effectively disable realtime validation.

<Playground>
  {() => {
    return (
      <FormState
        customErrorProp="errorMessage"
        validateOn="blur"
        validation={{
          name: required,
          address: {
            street: required,
            number: [required, isNumber],
          }
        }}
      >
        <Input name="name" title="Full name" />
        <fieldset name="address">
          <Input name="street" title="Street" />
          <Input type="text" name="number" title="House Number" />
        </fieldset>
        <button>Submit!</button>
      </FormState>
    )
  }}
</Playground>

### Keep validation errors on focus

By default, when an input has an error message and it's touched (focused),
the error message for the touched input will be cleared.

If you want to keep validations errors, specify `keepErrorOnFocus`:

<Playground>
  <FormState
    customErrorProp="errorMessage"
    validateOn="blur"
    keepErrorOnFocus
    validation={{
      name: required,
      address: {
        street: required,
        number: [required, isNumber],
      }
    }}
  >
    <Input name="name" title="Full name" />
    <fieldset name="address">
      <Input name="street" title="Street" />
      <Input type="text" name="number" title="House Number" />
    </fieldset>
    <button>Submit!</button>
  </FormState>
</Playground>

## Setting form data

It's possible to set the form data by passing an object whose keys mirror
form field's structure via `data` prop.

Currently the form keeps an internal state. When the `data` prop change
the internal state will be synced with the prop's value.

<Playground>
  <FormState
    data={{
      name: 'Obi Wan Kenobi',
      address: {
        street: 'A galaxy far far away',
        number: 'Never mind',
      }
    }}
    validation={{
      name: required,
      address: {
        street: required,
        number: [required, isNumber],
      }
    }}
  >
    <Input name="name" title="Full name" />
    <fieldset name="address">
      <Input name="street" title="Street" />
      <Input type="text" name="number" title="House Number" />
      <label htmlFor="number" role="alert" />
    </fieldset>
    <button>Submit!</button>
  </FormState>
</Playground>

## Validating `data` prop

When setting form data via `data` prop, by default the data will not be
validated. Sometimes there are situations where you may want to validate
and display errors, e.g.: server-side rendering. To validate the
data set through `data` prop, set `validateDataProp` to true:

<Playground>
  <FormState
    data={{
      name: 'Obi Wan Kenobi',
      address: {
        street: 'A galaxy far far away',
        number: 'Never mind',
      }
    }}
    validation={{
      name: required,
      address: {
        street: required,
        number: [required, isNumber],
      }
    }}
    customErrorProp="errorMessage"
    validateDataProp
  >
    <Input name="name" title="Full name" />
    <fieldset name="address">
      <Input name="street" title="Street" />
      <Input name="number" title="House Number" />
    </fieldset>
    <button>Submit!</button>
  </FormState>
</Playground>

## Setting errors manually

It is possible to overwrite form errors using `errors` prop. This is
useful for displaying server errors directly in fields.

<Playground>
  <FormState
    validation={{ name: required }}
    customErrorProp="errorMessage"
    data={{ email: 'foobar.com' }}
    errors={{ email: 'Invalid e-mail address' }}
  >
    <Input name="email" title="E-mail" />
    <Input name="password" title="Password" />
    <button>Submit!</button>
  </FormState>
</Playground>

## Getting form data realtime

It's possible to get the form data updates realtime using `onChange` prop.
This can be useful if you want to render components conditionally based
on form state.

> **Important:** It's not required to retro-feed `data` prop.

<Playground>
  <FormState
    onChange={(data, setState) => setState({ data })}
    validateDataProp
    customErrorProp="errorMessage"
    data={{
      name: 'Obi Wan Kenobi',
      address: {
        street: 'A galaxy far far away',
        number: "xxx",
        state: "ny",
      },
      accepted: false,
    }}
    validation={{
      name: required,
      address: {
        street: required,
        number: [required, isNumber],
      }
    }}
  >
    <Input name="name" title="Full name" />
    <label htmlFor="civil_state">
      Civil State
    </label>
    <input type="radio" name="civil_state" value="married" /> Married
    <input type="radio" name="civil_state" value="single" /> Single
    <fieldset name="address">
      <Input name="street" title="Street" />
      <Input name="number" title="House Number" />
      <label htmlFor="state">
        State
      </label>
      <select name="state">
        <option value="ca">California</option>
        <option value="ny">New York</option>
      </select>
    </fieldset>
    <label htmlFor="accept_terms">
      <input type="checkbox" name="accepted" />
      &nbsp;Accept the terms of service
    </label>
    <br/>
    <button>Submit!</button>
  </FormState>
</Playground>

## Continue using `onChange`

You can continue using `onChange` for receiving change events on specific
inputs. This may be necessary if you want to check when the user has
changed a single input value without needing to subscribe to form's
`onChange` (and thus having to keep comparing previous/next values):

<Playground>
  <FormState>
    <Input name="name" title="Full name" onChange={console.log} />
    <button>Submit!</button>
  </FormState>
</Playground>

## Creating composable forms

It's also possible to compose `<Form>` in custom components to create
composable, data-driven components: 

<Playground>
  {() => {
    const AddressForm = ({name, onChange, value, error}) => (
      <Form
        onChange={onChange}
        data={value}
        validation={{
          street: required,
          number: [required, isNumber],
        }}
      >
          <legend>Address</legend>
          <label htmlFor="street">
            Street
          </label>
          <input type="text" name="street" />
          <label htmlFor="number">
            House Number:
          </label>
          <input type="text" name="number" />
          <label htmlFor="postal_code">
            Number
          </label>
          <input type="text" name="postal_code" />
      </Form>
    )

    return (
      <FormState data={{ address: { number: '123' }}}>
        <label htmlFor="name">
          Name:
        </label>
        <input type="text" name="name" />
        <AddressForm name="address" />
        <button>Submit!</button>
      </FormState>
    )
  }}
</Playground>

>**NOTE**: Despite `<form>` not allowing  `<form>` as descendants by the
spec, Vanilla Form will render nested instances as `<fieldset>` to allow
composition.

